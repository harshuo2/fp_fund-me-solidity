{
  "language": "Solidity",
  "sources": {
    "contracts/FundMe.sol": {
      "content": "//SPDX-License-Identifier: MIT\n// 1. Pragma\npragma solidity 0.6.0;\n// 2. Imports\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\n//import \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol\";\nimport \"./PriceConvertor.sol\";\n\n// 3. Interfaces, Libraries, errors, Contracts\n// Error should be written as <ContractName>__<name of error>\n// error FundMe__NotOwner(); // this shit is too advanced for our solidity version\n\n/**@title A sample Funding Contract   // what this contract is\n * @author Patrick Collins   // name of author\n * @notice This contract is for creating a sample funding contract  // a note to the people(imporves readability)\n * @dev This implements price feeds as our library  // note for devs.\n */\ncontract FundMe {\n  // Type Declarations\n  using SafeMathChainlink for uint256;\n  using PriceConvertor for uint256; // ab iss var type (uint256) ke saare instance aise treat honge ki agar koi\n  // var ka use ho, to isko as parameter ki jagah, func ko iska func maan ke use kar sakte hain\n  // State variables\n  mapping(address => uint256) private addressToAmountFunded;\n  address payable private owner;\n  address[] private funders;\n  uint256 public constant MINIMUM_USD = 50 * 10**18;\n  AggregatorV3Interface private priceFeed; // this gives us the abi. abi along with address gives us a contract to interact with\n\n  // jo uske type ka wahi na value store karega. isliye AggregatorV3Interface ke type ka var banaya hai\n  // Events (we have none!)\n\n  // Modifiers\n  modifier checkOwner() {\n    require(msg.sender == owner, \"You're not the owner! Stop\");\n    //if (msg.sender != owner) revert FundMe__NotOwner(); // do this if error can be written at the top\n    _;\n  }\n\n  // Functions Order:\n  //// constructor\n  //// receive\n  //// fallback\n  //// external\n  //// public\n  //// internal\n  //// private\n  //// view / pure\n\n  constructor(address priceFeedAddress) public {\n    // ek baar jo value construcor mein def hojaye, usko kisi ka baap nahi badal sakta\n    owner = msg.sender;\n    priceFeed = AggregatorV3Interface(priceFeedAddress); // by passing the address, a contract is not created.\n  }\n\n  /// @notice Funds our contract based on the ETH/USD price\n  function fund() public payable {\n    addressToAmountFunded[msg.sender] += msg.value; //+ add karna hai\n    require(\n      msg.value.getConversionRate(priceFeed) >= MINIMUM_USD,\n      \"Aur paisa do madarchod\"\n    );\n    funders.push(msg.sender);\n  }\n\n  function withdraw() public payable checkOwner {\n    owner.transfer(address(this).balance);\n    for (\n      uint256 fundersIndex = 0;\n      fundersIndex < funders.length;\n      fundersIndex++\n    ) {\n      address funder = funders[fundersIndex];\n      addressToAmountFunded[funder] = 0;\n    }\n    funders = new address[](0);\n  }\n\n  function getAddressToAmountFunded(address funder)\n    public\n    view\n    returns (uint256)\n  {\n    return (addressToAmountFunded[funder]);\n  }\n\n  function getOwner() public view returns (address) {\n    return owner;\n  }\n\n  function getFunders(uint256 index) public view returns (address) {\n    return funders[index];\n  }\n\n  function getPriceFeed() public view returns (AggregatorV3Interface) {\n    return priceFeed;\n  }\n}\n// FOR FUNCTIONS IN PRICECONVERTOR.sol\n/** @notice Gets the amount that an address has funded\n *  @param fundingAddress the address of the funder\n *  @return the amount funded\n */\n// recieve aur fallback do special functions hain. one is called if no data is passed through 'transact'-> lower level\n// this is recieve(). Fallback is called if some value is passed which is not required by any functions.\n"
    },
    "@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "@chainlink/contracts/src/v0.6/vendor/SafeMathChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMathChainlink {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n"
    },
    "contracts/PriceConvertor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.0;\n\nimport \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConvertor {\n  // libraries cannot have constant state variables\n\n  function getVersion() public view returns (uint256) {\n    AggregatorV3Interface latestPrice = AggregatorV3Interface(\n      0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\n    );\n    return latestPrice.version();\n  }\n\n  function getLatestPrice(AggregatorV3Interface latestPrice)\n    public\n    view\n    returns (uint256)\n  {\n    // AggregatorV3Interface latestPrice = AggregatorV3Interface(\n    //   0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\n    // );\n    (, int256 answer, , , ) = latestPrice.latestRoundData();\n    return uint256(answer);\n  }\n\n  function getConversionRate(\n    uint256 ethAmounts,\n    AggregatorV3Interface priceFeed\n  ) internal view returns (uint256) {\n    //this ethAmounts is a value this func\n    // needs to run. Ye number hum input karenge\n    uint256 ethPriceInUSD = getLatestPrice(priceFeed);\n    uint256 ethAmountInUSD = ethAmounts * ethPriceInUSD;\n    return ethAmountInUSD / 10**8;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}